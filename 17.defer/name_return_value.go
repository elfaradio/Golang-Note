// Generated bY GPT

// 🧠 Basic Concept

// In Go:

//     When you return a value, the expression is evaluated immediately.

//     Then defer functions are executed.

//     Finally, the already-evaluated return value is sent back.

// ❌ Example 1: Without Named Return Value

package main

func main1() {

}

func getName() string {
	name := "Rakib"

	defer func() {
		name = name + " (modified)"
	}()

	return name
}

// 🔍 Step-by-step Execution:

//     name := "Rakib" — assign value.

//     return name — this evaluates name and copies "Rakib" as the return value.

//     defer runs: it modifies local variable name, but it doesn’t affect the return, because it's already copied.

//     Function returns "Rakib".

// 🧾 Output:

// Rakib

// Even though the deferred function changed name, the returned value was already fixed.
// ✅ Example 2: With Named Return Value

func getName1() (name string) {
	name = "Rakib"

	defer func() {
		name = name + " (modified)"
	}()

	return
}

// 🔍 Step-by-step Execution:

//     The function declares a named return value: name.

//     name = "Rakib" — assign value to named return variable.

//     return — does not evaluate an expression, so it waits until defer runs.

//     defer runs: it modifies the shared name variable.

//     Function returns the modified value "Rakib (modified)".

// 🧾 Output:

// Rakib (modified)

// 🔬 Memory Diagram

// Let’s visualize what's happening:
// ❌ Without Named Return

// name := "Rakib"
// -------------------------
// | Stack Frame           |
// |-----------------------|
// | name = "Rakib"        |   <- local to function
// | return value = "Rakib"|   <- evaluated BEFORE defer
// -------------------------
// defer modifies local `name`, but it's too late

// ✅ With Named Return

// (name string) return variable
// -------------------------
// | Stack Frame           |
// |-----------------------|
// | name = "Rakib"        |   <- shared between func and defer
// | return uses `name`    |
// -------------------------
// defer modifies `name` before final return

// 🔁 Summary Table
// Case	Can modify return?	Why?
// return name (unnamed)	❌ No	Return value is evaluated before defer
// return (named variable)	✅ Yes	defer modifies the shared named return variable
