// Generated bY GPT

// ğŸ§  Basic Concept

// In Go:

//     When you return a value, the expression is evaluated immediately.

//     Then defer functions are executed.

//     Finally, the already-evaluated return value is sent back.

// âŒ Example 1: Without Named Return Value

package main

func main1() {

}

func getName() string {
	name := "Rakib"

	defer func() {
		name = name + " (modified)"
	}()

	return name
}

// ğŸ” Step-by-step Execution:

//     name := "Rakib" â€” assign value.

//     return name â€” this evaluates name and copies "Rakib" as the return value.

//     defer runs: it modifies local variable name, but it doesnâ€™t affect the return, because it's already copied.

//     Function returns "Rakib".

// ğŸ§¾ Output:

// Rakib

// Even though the deferred function changed name, the returned value was already fixed.
// âœ… Example 2: With Named Return Value

func getName1() (name string) {
	name = "Rakib"

	defer func() {
		name = name + " (modified)"
	}()

	return
}

// ğŸ” Step-by-step Execution:

//     The function declares a named return value: name.

//     name = "Rakib" â€” assign value to named return variable.

//     return â€” does not evaluate an expression, so it waits until defer runs.

//     defer runs: it modifies the shared name variable.

//     Function returns the modified value "Rakib (modified)".

// ğŸ§¾ Output:

// Rakib (modified)

// ğŸ”¬ Memory Diagram

// Letâ€™s visualize what's happening:
// âŒ Without Named Return

// name := "Rakib"
// -------------------------
// | Stack Frame           |
// |-----------------------|
// | name = "Rakib"        |   <- local to function
// | return value = "Rakib"|   <- evaluated BEFORE defer
// -------------------------
// defer modifies local `name`, but it's too late

// âœ… With Named Return

// (name string) return variable
// -------------------------
// | Stack Frame           |
// |-----------------------|
// | name = "Rakib"        |   <- shared between func and defer
// | return uses `name`    |
// -------------------------
// defer modifies `name` before final return

// ğŸ” Summary Table
// Case	Can modify return?	Why?
// return name (unnamed)	âŒ No	Return value is evaluated before defer
// return (named variable)	âœ… Yes	defer modifies the shared named return variable
