// Generated By chatgpt


ðŸ“Œ 1. Slice Declaration and Initialization
âœ… Using []type with make or literal

var s []int                     // nil slice
s = []int{1, 2, 3}              // initialized with values
s = make([]int, 5)             // length 5, capacity 5
s = make([]int, 5, 10)         // length 5, capacity 10

ðŸ“Œ 2. Slice Literals

nums := []int{1, 2, 3}
names := []string{"Alice", "Bob"}
matrix := [][]int{{1, 2}, {3, 4}}

ðŸ“Œ 3. Indexing and Slicing

s := []int{10, 20, 30, 40, 50}
x := s[1:4]    // [20 30 40]
x = s[:3]      // [10 20 30]
x = s[2:]      // [30 40 50]

ðŸ“Œ 4. Length and Capacity

len(s) // returns the number of elements
cap(s) // returns the capacity (from start index to end of backing array)

ðŸ“Œ 5. Nil vs Empty Slice

var a []int    // nil slice, len = 0, cap = 0, a == nil
b := []int{}   // empty slice, len = 0, cap = 0, b != nil

ðŸ“Œ 6. Appending Elements

s := []int{1, 2}
s = append(s, 3, 4)          // [1 2 3 4]
s = append(s, anotherSlice...) // append another slice

    When capacity is exceeded, Go allocates a new array with increased capacity.

ðŸ“Œ 7. Copying Slices

src := []int{1, 2, 3}
dst := make([]int, len(src))
copy(dst, src) // copies elements from src to dst

ðŸ“Œ 8. Modifying Underlying Array

Slices share the same backing array:

a := []int{1, 2, 3}
b := a[1:]
b[0] = 100
// a = [1, 100, 3] â†’ both a and b refer to the same array

ðŸ“Œ 9. Multi-Dimensional Slices

grid := make([][]int, 3)
for i := range grid {
	grid[i] = make([]int, 3)
}

ðŸ“Œ 10. Iterating Over Slices

s := []int{10, 20, 30}
for i, v := range s {
	fmt.Println(i, v)
}

ðŸ“Œ 11. Slices as Function Parameters

Slices are passed by reference (copy of slice header):

func modify(s []int) {
	s[0] = 100
}

Changes reflect in the original slice.
ðŸ“Œ 12. Reslicing

s := []int{1, 2, 3, 4, 5}
s = s[:3] // [1 2 3]
s = s[1:] // [2 3]

You can re-slice as long as it's within capacity.
ðŸ“Œ 13. Slice Internals

A slice header contains:

    Pointer to the underlying array

    Length

    Capacity

type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

ðŸ“Œ 14. Slice Growth Strategy

When appending:

    Capacity may double, or grow more slowly depending on size.

    Go runtime handles reallocation automatically.

ðŸ“Œ 15. Removing Elements
Remove at index i:

s = append(s[:i], s[i+1:]...)

Remove from front or back:

s = s[1:]       // remove first
s = s[:len(s)-1] // remove last

ðŸ“Œ 16. Insert Elements

Insert at position i:

s = append(s[:i], append([]T{value}, s[i:]...)...)

ðŸ“Œ 17. Sorting Slices

import "sort"

sort.Ints(s)
sort.Strings(strs)
sort.Slice(people, func(i, j int) bool {
	return people[i].Age < people[j].Age
})

ðŸ“Œ 18. Comparing Slices

Use reflect.DeepEqual:

reflect.DeepEqual(a, b) // true if equal

For Go 1.18+, use slices.Equal() from golang.org/x/exp/slices.
ðŸ“Œ 19. Generic Slice Utilities (Go 1.18+)

With generics or slices package:

import "golang.org/x/exp/slices"

slices.Contains(s, 3)
slices.Index(s, 5)
slices.Clone(s)
slices.Reverse(s)