package main

import (
	"fmt"
	"reflect"
	"slices"
	"sort"
)

//Farhadul Islam CSE-56 IIUC

func main() {

	//  Popular ,under the array,powerful,more features

	var slc = []int{}

	fmt.Print(slc, "\n") //[]

	fmt.Printf("%T\n", slc) // int[]

	var slc1 = []int{1, 3, 5, 7}

	fmt.Print(slc1, "\n")

	fmt.Println(len(slc), len(slc1)) // 0,4 length of slice

	slc1 = append(slc1, 2) // 2 add also append(slc1,2,3,4..)

	fmt.Println(len(slc), len(slc1)) // 0,5 ... increase by 1 bcz of append

	//slc1 = append(slc1[1:3]) // give 1-2 pos and remove baki element

	fmt.Println(len(slc1)) // after removing 2

	slc1 = append(slc1[1:3], 2, 8, 9) //give 1-2 pos and remove baki element  and then add 2,8,9

	fmt.Print(slc1, "\n")

	fmt.Println(len(slc1)) // 5

	scl2 := make([]int, 6) // another way using make()

	scl2[5] = 5

	fmt.Println(scl2, len(scl2)) // 6 length

	scl2 = append(scl2, 2, 3, 4)

	fmt.Println(scl2, len(scl2)) // after append length increase even init was 6

	// func (a SortBy) Len() int           { return len(a) }
	// func (a SortBy) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
	// func (a SortBy) Less(i, j int) bool { return a[i] < a[j] }

	//sort.Ints(scl2) // sort the array

	sort.IntsAreSorted(scl2) // true if sorted

	// how to remove a value from slice based on index

	dx := 7

	scl2 = append(scl2[:dx], scl2[dx+1:]...) // remove 7th index

	fmt.Println(scl2)

	extra()

}

func extra() {

	// Generated By chatgpt

	/*
	 1. Slice Declaration and Initialization
	 Using []type with make or literal
	*/

	var ss []int              // nil slice
	ss1 := []int{1, 2, 3}     // initialized with values
	ss2 := make([]int, 5)     // length 5, capacity 5
	ss3 := make([]int, 5, 10) // length 5, capacity 10
	fmt.Print(ss1, ss2, ss3, ss)

	// 2. Slice Literals

	nums := []int{1, 2, 3}
	names := []string{"Alice", "Bob"}
	matrix := [][]int{{1, 2}, {3, 4}}

	fmt.Print(nums, names, matrix)

	//3. Indexing and Slicing

	var s = []int{10, 20, 30, 40, 50}
	x1 := s[1:4] // [20 30 40]
	x2 := s[:3]  // [10 20 30]
	x3 := s[2:]  // [30 40 50]
	fmt.Print(x1, x2, x3)
	// 4. Length and Capacity

	//len(s) // returns the number of elements
	//cap(s) // returns the capacity (from start index to end of backing array)

	// 5. Nil vs Empty Slice

	var a []int  // nil slice, len = 0, cap = 0, a == nil
	b := []int{} // empty slice, len = 0, cap = 0, b != nil

	// 6. Appending Elements

	sss := []int{1, 2}

	fmt.Print(sss)

	sss = append(s, 3, 4) // [1 2 3 4]

	//sss = append(s, anotherSlice...) // append another slice

	fmt.Print(sss)

	//When capacity is exceeded, Go allocates a new array with increased capacity.

	// 7. Copying Slices

	src := []int{1, 2, 3}
	dst := make([]int, len(src))
	copy(dst, src) // copies elements from src to dst

	/// 8. Modifying Underlying Array

	//Slices share the same backing array:

	var aa = []int{1, 2, 3}
	var bb = a[1:]
	//bb[0] = 100
	fmt.Print(aa, bb)
	// a = [1, 100, 3] â†’ both a and b refer to the same array

	// 9. Multi-Dimensional Slices

	grid := make([][]int, 3)
	for i := range grid {
		grid[i] = make([]int, 3)
	}

	// 10. Iterating Over Slices

	var ssss = []int{10, 20, 30}
	for i, v := range ssss {
		fmt.Println(i, v)
	}

	// 11. Slices as Function Parameters

	//Slices are passed by reference (copy of slice header):

	/*
	   func modify(s []int) {
	   	s[0] = 100
	   }

	*/

	//Changes reflect in the original slice.
	// 12. Reslicing

	var sS = []int{1, 2, 3, 4, 5}
	fmt.Print(sS[:3]) // [1 2 3]
	sS = sS[1:]       // [2 3]

	fmt.Print(sS)

	//You can re-slice as long as it's within capacity.
	// 13. Slice Internals

	/*
	   A slice header contains:

	       Pointer to the underlying array

	       Length

	       Capacity

	   type SliceHeader struct {
	   	Data uintptr
	   	Len  int
	   	Cap  int
	   }

	*/

	// 14. Slice Growth Strategy

	/* When appending:

	   Capacity may double, or grow more slowly depending on size.

	   Go runtime handles reallocation automatically.
	*/

	// 15. Removing Elements
	//Remove at index i:

	//s = append(s[:i], s[i+1:]...)

	//Remove from front or back:

	s = s[1:]        // remove first
	s = s[:len(s)-1] // remove last

	// 16. Insert Elements

	//Insert at position i:

	//s = append(s[:i], append([]T{value}, s[i:]...)...)

	//17. Sorting Slices
	/*
		sort.Ints(s)
		sort.Strings(strs)
		sort.Slice(people, func(i, j int) bool {
			return people[i].Age < people[j].Age
		})
	*/

	// 18. Comparing Slices

	//Use reflect.DeepEqual:

	reflect.DeepEqual(a, b) // true if equal

	//For Go 1.18+, use slices.Equal() from golang.org/x/exp/slices.

	/// 19. Generic Slice Utilities (Go 1.18+)

	//With generics or slices package:

	//import "golang.org/x/exp/slices"

	slices.Contains(s, 3)
	slices.Index(s, 5)
	slices.Clone(s)
	slices.Reverse(s)
	//fmt.Print(slices)

}
